Lib.Inventory=Lib.Inventory or{}Lib.Inventory.CanCarry=function(a,b,c)b=type(b)=="string"and{b}or b;local d=Lib.Inventory.GetWeight(b)*c;local e=Lib.Inventory.GetMaxWeight()return d<=e end;Lib.Inventory.MergeDuplicateItems=function(b)local f={}for g=1,#b do local h=false;for i=1,#f do if b[g].name==f[i].name and Lib.Table.Matches(b[g].metadata,f[i].metadata)then f[i].count=f[i].count+b[g].count;h=true end end;if not h then f[#f+1]=b[g]end end;return f end;Lib.Inventory.Transaction=function(a,j,k)local l=Lib.Inventory.MergeDuplicateItems(j)local m=Lib.Inventory.MergeDuplicateItems(k)if type(m)~="table"then return print("Give items must be a table")end;if type(l)~="table"then return print("Take items must be a table")end;local n={give=Lib.Inventory.GetItemTableWeight(m),take=Lib.Inventory.GetItemTableWeight(l),max=Lib.Inventory.GetMaxWeight(),current=Lib.Inventory.GetPlayerInventoryWeight(a)}local o=n.give-n.take;local p=n.current+o;if p>n.max then return false,"Cannot carry new weight"end;for g=1,#l do if not Lib.Inventory.HasItem(a,l[g].name,l[g].count,l[g].metadata)then local q=""if l[g].metadata then q=" with metadata: "..json.encode(l[g].metadata)end;return false,("Cannot take item: %s, count: %s%s"):format(l[g].name,l[g].count,q)end end;local r={}for g=1,#l do if not Lib.Inventory.RemoveItem(a,l[g].name,l[g].count,l[g].metadata)then for i=1,g-1 do r[#r+1]=l[i]end;return false,("Failed to remove item: %s, count: %s"):format(l[g].name,l[g].count),r end end;for g=1,#m do if not Lib.Inventory.AddItem(a,m[g].name,m[g].count,m[g].metadata)then for i=g+1,#m do Lib.Inventory.RemoveItem(a,m[i].name,m[i].count,m[i].metadata)end;return false,("Failed to add item: %s, count: %s"):format(m[g].name,m[g].count),r end end;return true end